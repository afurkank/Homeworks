In the following knn implementation, incorporate the "weighted_voting" parameter into the function so that the model uses weighted voting when making predictions. In other words, closer neighbors will have a greater influence on the prediction. Here is the implementation so far:
```
import pandas as pd
import numpy as np

def knn(
        existing_data: pd.DataFrame,
        test_data: pd.DataFrame,
        k: int,
        distance_method: str,
        re_training: bool,
        distance_threshold: float,
        weighted_voting: bool
    ):

    assert k >= 3 and k <= 10, "k must be within range [3, 10]"
    assert distance_method in ["euclidean", "manhattan", "chebyshev"], "distance method is not recognized"

    train_labels = existing_data['label'].to_numpy()
    train_values = existing_data.drop(columns=['label']).to_numpy()
    
    test_values = test_data.drop(columns=['label']).to_numpy()
    
    distances = []
    if distance_method == 'euclidean':
        for test_item in test_values:
            distance = np.sqrt(np.sum((test_item - train_values)**2, axis=1))
            distances.append(distance)
    elif distance_method == 'manhattan':
        for test_item in test_values:
            distance = np.sum(np.abs(test_item - train_values), axis=1)
            distances.append(distance)
    else:  # distance_method == 'chebyshev'
        for test_item in test_values:
            distance = np.max(np.abs(test_item - train_values), axis=1)
            distances.append(distance)
    
    distances = np.array(distances)

    # Apply distance threshold
    distances[distances > distance_threshold] = np.inf

    sorted_indices = np.argsort(distances, axis=1)
    for i, indices in enumerate(sorted_indices):
        distances[i] = distances[i][indices]

    truncated_indices = sorted_indices[:, :k]
    closest_labels = []
    for i, indices in enumerate(truncated_indices):
        closest_labels.append(train_labels[indices])
    closest_labels = np.array(closest_labels)

    def _majority_vote(array, k):
        sums = np.sum(array, axis=1)
        return (sums >= k / 2).astype(int)
    
    majority_voted_labels = _majority_vote(closest_labels, k)
    
    return pd.Series(majority_voted_labels)

```
